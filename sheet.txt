### Mobile Application Development Cheat Sheet

---

### **Kotlin for Android**

**Why Kotlin?**
- Less code, greater readability
- Interoperability with Java
- Safe and easy to learn
- Supports Android Jetpack and libraries

**Type Inference**
- Automatically determines variable type.

**Null Safety**
- Prevents null pointer exceptions with `null` handling (`?` and `!!`).

---

### **Android Project Structure**
- **src/main/java**: Java/Kotlin source files.
- **res/layout**: XML layout files.
- **res/values**: XML resource files (strings, colors).

---

### **Activity Lifecycle**
- **onCreate()**: Initialize activity.
- **onStart()**: Activity becomes visible.
- **onResume()**: Activity starts interacting with the user.
- **onPause()**: Another activity is taking focus.
- **onStop()**: Activity no longer visible.
- **onDestroy()**: Activity is destroyed.

---

### **Intents**
- **Explicit Intent**: Specific component.
  ```kotlin
  val intent = Intent(this, TargetActivity::class.java)
  startActivity(intent)
  ```

- **Implicit Intent**: General action.
  ```kotlin
  val intent = Intent(Intent.ACTION_VIEW)
  intent.data = Uri.parse("http://www.example.com")
  startActivity(intent)
  ```

**Features:**
- **Starting Activities**: `startActivity(intent)`
- **Starting Services**: `startService(intent)`
- **Broadcasting**: `sendBroadcast(intent)`

---

### **Broadcast Receivers**
- Listen for system-wide broadcast announcements.
  ```kotlin
  class MyReceiver : BroadcastReceiver() {
      override fun onReceive(context: Context, intent: Intent) {
          // Handle the broadcast
      }
  }
  ```

---

### **ViewModel**
- Manages UI-related data lifecycle.
  ```kotlin
  class MainActivityViewModel : ViewModel() {
      private val _data = MutableLiveData<String>()
      val data: LiveData<String> = _data

      fun setData(value: String) {
          _data.value = value
      }
  }
  ```

**Usage:**
  ```kotlin
  val viewModel = ViewModelProvider(this).get(MainActivityViewModel::class.java)
  ```

---

### **RecyclerView**
1. **Add Dependency:**
   ```gradle
   implementation 'androidx.recyclerview:recyclerview:1.3.1'
   ```

2. **Layout:**
   ```xml
   <androidx.recyclerview.widget.RecyclerView
       android:id="@+id/recyclerView"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
   ```

3. **Adapter:**
   ```kotlin
   class MyAdapter(private val dataList: List<String>) : RecyclerView.Adapter<MyAdapter.ViewHolder>() {
       class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
           val textView: TextView = itemView.findViewById(R.id.textView)
       }

       override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
           val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
           return ViewHolder(view)
       }

       override fun onBindViewHolder(holder: ViewHolder, position: Int) {
           holder.textView.text = dataList[position]
       }

       override fun getItemCount() = dataList.size
   }
   ```

4. **Activity:**
   ```kotlin
   val recyclerView: RecyclerView = findViewById(R.id.recyclerView)
   recyclerView.layoutManager = LinearLayoutManager(this)
   recyclerView.adapter = MyAdapter(myDataList)
   ```

---

### **Room Database**
1. **Dependencies:**
   ```gradle
   implementation "androidx.room:room-runtime:2.5.0"
   kapt "androidx.room:room-compiler:2.5.0"
   implementation "androidx.room:room-ktx:2.5.0"
   ```

2. **Entity:**
   ```kotlin
   @Entity
   data class Course(
       @PrimaryKey val courseId: String,
       val courseName: String,
       val credits: Int
   )
   ```

3. **DAO:**
   ```kotlin
   @Dao
   interface CourseDao {
       @Insert
       fun insertCourse(course: Course)

       @Update
       fun updateCourse(course: Course)

       @Delete
       fun deleteCourse(course: Course)

       @Query("SELECT * FROM Course")
       fun getAllCourses(): List<Course>
   }
   ```

4. **Database:**
   ```kotlin
   @Database(entities = [Course::class], version = 1)
   abstract class AppDatabase : RoomDatabase() {
       abstract fun courseDao(): CourseDao
   }
   ```

5. **Usage:**
   ```kotlin
   val db = Room.databaseBuilder(
       applicationContext,
       AppDatabase::class.java, "course-database"
   ).build()
   ```

---

### **Services**

**Types:**
- **Foreground Service**: User-visible ongoing operations (e.g., music player).
- **Background Service**: Long-running operations in the background.
- **Bound Service**: Allows components to bind and interact with the service.

**Example Foreground Service:**
```kotlin
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        val notification = Notification.Builder(this, CHANNEL_ID)
            .setContentTitle("Service Running")
            .setContentText("Service is running in the foreground")
            .setSmallIcon(R.drawable.ic_notification)
            .build()
        startForeground(1, notification)
        return START_STICKY
    }

    override fun onBind(intent: Intent): IBinder? {
        return null
    }
}
```

---

### **Button Click Handling**
```kotlin
val myButton: Button = findViewById(R.id.myButton)
myButton.setOnClickListener {
    // Handle button click
    Toast.makeText(this, "Button clicked!", Toast.LENGTH_SHORT).show()
}
```

### **Date Picker Handling**
```kotlin
val datePicker = findViewById<DatePicker>(R.id.datePicker)
datePicker.init(year, month, day) { view, year, monthOfYear, dayOfMonth ->
    val selectedDate = "$dayOfMonth/${monthOfYear + 1}/$year"
    Toast.makeText(this, "Selected date: $selectedDate", Toast.LENGTH_SHORT).show()
}
```

---

### **Exam Sample Question Solution**

**a) Course Entity**
```kotlin
@Entity(tableName = "course_table")
data class Course(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    @ColumnInfo(name = "course_id") val courseId: String,
    @ColumnInfo(name = "course_name") val courseName: String,
    @ColumnInfo(name = "credits") val credits: Int
)
```

**b) Course DAO**
```kotlin
@Dao
interface CourseDao {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(course: Course)

    @Update
    suspend fun update(course: Course)

    @Delete
    suspend fun delete(course: Course)

    @Query("SELECT * FROM course_table ORDER BY course_name ASC")
    fun getAllCourses(): LiveData<List<Course>>
}
```

**c) Lifecycle-Aware Components and Room Database Interaction**
- **ViewModel**: ViewModel interacts with the Room database and stores UI-related data. This data survives configuration changes.
Lifecycle Awareness: ViewModel is designed to be lifecycle-aware, meaning it won't cause 
memory leaks and it'll be cleared once its associated lifecycle is destroyed.

- **LiveData**: Used within ViewModel to observe data changes. When data in the database changes, LiveData updates the UI components.
- **Repository**: Acts as a mediator between ViewModel and Room database. It handles data operations and abstracts the data source from ViewModel.

```kotlin
class CourseViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: CourseRepository
    val allCourses: LiveData<List<Course>>

    init {
        val courseDao = AppDatabase.getDatabase(application).courseDao()
        repository = CourseRepository(courseDao)
        allCourses = repository.allCourses
    }

    fun insert(course: Course) = viewModelScope.launch {
        repository.insert(course)
    }

    fun update(course: Course) = viewModelScope.launch {
        repository.update(course)
    }

    fun delete(course: Course) = viewModelScope.launch {
        repository.delete(course)
    }
}
```

### Mobile Application Development Short Note with Code Examples

---

### Tutorial 01: Kotlin Basics

**Variables and Data Types:**
```kotlin
val myVal: Int = 10 // Immutable variable
var myVar: String = "Hello" // Mutable variable
```

**Functions:**
```kotlin
fun calculateCircumference(radius: Double): Double {
    return 2 * Math.PI * radius
}
```

**Conditions and Loops:**
```kotlin
fun determineGrade(mark: Int): String {
    return when {
        mark >= 75 -> "A"
        mark >= 65 -> "B"
        mark >= 50 -> "C"
        mark >= 35 -> "D"
        else -> "F"
    }
}

for (i in 1..10) {
    println(i)
}
```

**Collections:**
```kotlin
val list = listOf(1, 2, 3)
val mutableList = mutableListOf(1, 2, 3)
```

---

### Tutorial 03: Simple Calculator

**activity_main.xml:**
```xml
<LinearLayout ...>
    <EditText android:id="@+id/edtNumber1" ... />
    <EditText android:id="@+id/edtNumber2" ... />
    <Button android:id="@+id/btnPlus" ... />
    <!-- Other buttons -->
</LinearLayout>
```

**Create Calculator Class:**
```kotlin
class Calculator(private val number1: Double, private val number2: Double) {
    fun add() = number1 + number2
    fun subtract() = number1 - number2
    fun multiply() = number1 * number2
    fun divide() = number1 / number2
}
```

**MainActivity:**
```kotlin
class MainActivity : AppCompatActivity() {
    lateinit var edtNumber1: EditText
    lateinit var edtNumber2: EditText

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        edtNumber1 = findViewById(R.id.edtNumber1)
        edtNumber2 = findViewById(R.id.edtNumber2)
    }
  //  Implement a function passing the view as a parameter to implement the calculation.
    fun buttonClick(v: View) {
        val number1 = edtNumber1.text.toString().toDouble()
        val number2 = edtNumber2.text.toString().toDouble()
        val calculator = Calculator(number1, number2)
        val result = when (v.id) {
            R.id.btnPlus -> calculator.add()
            R.id.btnMinus -> calculator.subtract()
            R.id.btnMultiply -> calculator.multiply()
            R.id.btnDivide -> calculator.divide()
            else -> 0.0
        }
        println(result) // This will print the output on the terminal
    }
}
```

**Navigation to DisplayActivity:**
```kotlin
val intent = Intent(this, DisplayActivity::class.java)
intent.putExtra("answer", ans)
startActivity(intent)
```

---

### Tutorial 05: Form Validation

**UI Elements in XML:**
```xml
<LinearLayout ...>
    <EditText android:id="@+id/edtStudentId" ... />
    <Spinner android:id="@+id/spnYear" ... />
    <!-- Other UI elements -->
</LinearLayout>
```

**ValidationResult Class:**
```kotlin
sealed class ValidationResult {
    data class Empty(val errorMessage: String): ValidationResult()
    data class Invalid(val errorMessage: String): ValidationResult()
    object Valid : ValidationResult()
}
```

**FormData Class:**
```kotlin
class FormData(
    private var studentID: String,
    private var year: String,
    private var semester: String,
    private var agree: Boolean
) {
    fun validateStudentId(): ValidationResult {
        return if (studentID.isEmpty()) {
            ValidationResult.Empty("Student ID is empty")
        } else if (!studentID.startsWith("IT")) {
            ValidationResult.Invalid("Should be starting with IT")
        } else if (studentID.length != 10) {
            ValidationResult.Invalid("Student ID should have 10 characters")
        } else {
            ValidationResult.Valid
        }
    }

    fun validateYear(): ValidationResult {
        return if (year.isEmpty()) {
            ValidationResult.Empty("Year is empty")
        } else {
            ValidationResult.Valid
        }
    }

    fun validateSemester(): ValidationResult {
        return if (semester.isEmpty()) {
            ValidationResult.Empty("Semester is empty")
        } else {
            ValidationResult.Valid
        }
    }

    fun validateAgreement(): ValidationResult {
        return if (!agree) {
            ValidationResult.Invalid("You must agree to the terms and conditions")
        } else {
            ValidationResult.Valid
        }
    }
}
```

**MainActivity Validation Logic:**
```kotlin
lateinit var edtStudentId: EditText
lateinit var spnYear: Spinner
lateinit var spnSemester: Spinner
lateinit var cbAgree: CheckBox

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    edtStudentId = findViewById(R.id.edtStudentId)
    spnYear = findViewById(R.id.spnYear)
    spnSemester = findViewById(R.id.spnSemester)
    cbAgree = findViewById(R.id.cbAgree)
}

**implement the displayAlert function**

fun displayAlert(title:String, message:String){
 val builder = AlertDialog.Builder(this)
 builder.setTitle(title)
 builder.setMessage(message)
 builder.setPositiveButton("OK") { dialog, which ->
 // Do something when the "OK" button is clicked
 }
 val dialog = builder.create()
 dialog.show()
}

**implement the submit function**

fun submit(v: View) {
    val myForm = FormData(
        edtStudentId.text.toString(),
        spnYear.selectedItem.toString(),
        spnSemester.selectedItem.toString(),
        cbAgree.isChecked
    )

    val studentIdValidation = myForm.validateStudentId()
    val spnYearValidation = myForm.validateYear()
    val spnSemesterValidation = myForm.validateSemester()
    val cbAgreeValidation = myForm.validateAgreement()

    when (studentIdValidation) {
        is ValidationResult.Valid -> {}
        is ValidationResult.Invalid -> edtStudentId.error = studentIdValidation.errorMessage
        is ValidationResult.Empty -> edtStudentId.error = studentIdValidation.errorMessage
    }

    // Similar validation for year, semester, and agreement
**is ValidationResult.Empty**
is ValidationResult.Empty ->{
val tv: TextView = spnSemester.selectedView  as TextView
tv.error = ""
tv.text = spnSemesterValidation.errorMessage
}

**is ValidationResult.Invalid **
is ValidationResult.Invalid ->{
displayAlert("Error" , cbAgreeValidation. errorMessage)
}

```

---

### Tutorial 06: RecyclerView

**Dependencies:**
```gradle
implementation 'androidx.recyclerview:recyclerview:1.3.1'
```

**Item Layout (item_layout.xml):**
```xml
<LinearLayout ...>
    <TextView android:id="@+id/tvUserName" ... />
    <TextView android:id="@+id/tvDescription" ... />
    <Button android:id="@+id/btnLike" ... />
</LinearLayout>
```

**Data Class:**
```kotlin
data class Post(val userName: String, val description: String, val likes: Int)
```

**ViewHolder:**
```kotlin
class MyDataVH(itemView: View) : RecyclerView.ViewHolder(itemView) {
    val tvUserName: TextView = itemView.findViewById(R.id.tvUserName)
    val tvDescription: TextView = itemView.findViewById(R.id.tvDescription)
    val btnLike: Button = itemView.findViewById(R.id.btnLike)
}
```

**Adapter:**
```kotlin
class MyDataAdapter(private val data: List<Post>) : RecyclerView.Adapter<MyDataVH>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyDataVH {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
        return MyDataVH(view)
    }

    override fun getItemCount() = data.size

    override fun onBindViewHolder(holder: MyDataVH, position: Int) {
        val post = data[position]
        holder.tvUserName.text = post.userName
        holder.tvDescription.text = post.description
        holder.btnLike.text = "${post.likes} Likes"
    }
}
```

**MainActivity:** recycle view display data in a view 
```kotlin
class MainActivity : AppCompatActivity() {
    private val postsList = mutableListOf<Post>(
        Post("User1", "Description1", 10),
        Post("User2", "Description2", 20)
    )

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val recyclerView: RecyclerView = findViewById(R.id.recyclerView)
        recyclerView.layoutManager = LinearLayoutManager(this)
        recyclerView.adapter = MyDataAdapter(postsList)
    }
}
```
** GridLayout manager as follows.**
override fun onCreate(savedInstanceState: Bundle?) {
 super.onCreate(savedInstanceState)
 setContentView(R.layout.activity_main)
 val rvList:RecyclerView = findViewById(R.id.rvList)
 //rvList.layoutManager = LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false)
 rvList.layoutManager = GridLayoutManager(this,2,
 GridLayoutManager.VERTICAL,false)
 val adapter = MyDataAdapter(postsList)
 rvList.adapter = adapter
 }
---

---
### Tutorial 07: ViewModel and Intents

**ViewModel:**
```kotlin
class MainActivityData : ViewModel() {
    private val _count = MutableLiveData<Int>().apply { value = 0 }
    val count: LiveData<Int> = _count

    fun increment() {
        _count.value = _count.value!! + 1
    }
}
```

**Using ViewModel in Activity:**
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: MainActivityData

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewModel = ViewModelProvider(this).get(MainActivityData::class.java)
        val textView: TextView = findViewById(R.id.textView)
        val button: Button = find```kotlin
        val button: Button = findViewById(R.id.button)

        viewModel.count.observe(this, Observer {
            textView.text = it.toString()
        })

        button.setOnClickListener {
            viewModel.increment()
        }
    }
}
```

Explicit intents specify the target component by name, while implicit intents declare a general action allowing another app's component to handle it.

**Explicit Intent:**
```kotlin
button.setOnClickListener {
    val intent = Intent(this, TargetActivity::class.java)
    startActivity(intent)
}
```

**Implicit Intent:**
```kotlin
button.setOnClickListener {
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("http://www.example.com"))
    startActivity(intent)
}
```
**For this you need to implement object from Activity Launcher on class level as follows:**
val thumbnailLauncer = registerForActivityResult(
 ActivityResultContracts.StartActivityForResult()
) {
 if (it.resultCode == RESULT_OK){
 val data = it.data
 val imageBitmap = data?.extras?.get("data") as? Bitmap
 imageView.setImageBitmap(imageBitmap)
 }
}
**Now implement the button7 code as follows:**
button7.setOnClickListener {
 val intent = Intent()
 intent.action = MediaStore.ACTION_IMAGE_CAPTURE
 thumbnailLauncer.launch(intent)
}
---

### Tutorial 08: Fragments

Advantages of Using Fragments:
• Reusability: You can use the same fragment in multiple activities.
• Adaptability: With fragments, you can create more flexible and dynamic UIs that can adapt to 
different device configurations

FrameLayout is a layout manager in Android used to display a single item or stack multiple child views on top of each other, often utilized for simple layouts and overlay effects.

**Fragment Layout (fragment_home.xml):**
```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello Fragment" />
</FrameLayout>
```

**HomeFragment:**
```kotlin
class HomeFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_home, container, false)
    }
}
```

**MainActivity:**
```kotlin
class MainActivity : AppCompatActivity() {
    private val homeFragment = HomeFragment()
    private val settingsFragment = SettingsFragment()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        supportFragmentManager.beginTransaction()
            .add(R.id.fragmentContainer, homeFragment)
            .commit()

        val button: Button = findViewById(R.id.button)
        val button2: Button = findViewById(R.id.button2)

        button.setOnClickListener {
            supportFragmentManager.beginTransaction()
                .replace(R.id.fragmentContainer, homeFragment)
                .commit()
        }

        button2.setOnClickListener {
            supportFragmentManager.beginTransaction()
                .replace(R.id.fragmentContainer, settingsFragment)
                .commit()
        }
    }
}
```

---

### Tutorial 09: Kotlin Coroutines

- **Coroutines:** Lightweight threads launched with builders like `launch` or `async`, ideal for long-running or CPU-bound tasks without blocking the main thread.
- **Suspending Functions:** Functions with the `suspend` modifier that can be paused and resumed later, callable only from another suspending function or within a coroutine.
- **CoroutineScope:** Interface defining a scope for new coroutines, where every coroutine builder inherits its coroutine context.
- **Dispatchers:** Determine the thread on which the coroutine will run, including options like `Dispatchers.Main`, `Dispatchers.IO`, and `Dispatchers.Default`.
- **Jobs and Deferred:** Jobs are cancellable entities with a lifecycle, similar to Future but with a different API. Deferred represents a non-blocking cancelable future, essentially a Job with a result.
- **Simplicity:** Allows writing asynchronous code similar to synchronous code, enhancing readability and comprehension.
- **Efficiency:** Reduces overhead by eliminating the need for context switching on the thread scheduler.
- **Flexibility:** Enables developers to decide where coroutines should run, such as the main thread or background, using dispatchers.
- **Usage:** Widely employed for network API calls, database transactions, file I/O operations, and any other tasks that could potentially block the main thread.

- **CoroutineScope:** Manages coroutine lifecycle and provides a context for coroutine execution.
- **Cancellation:** Cancelling a CoroutineScope cancels all coroutines launched within it.
- **Dispatchers:** Class providing thread pools and contexts for coroutine execution.
- **Dispatchers.Default:** Used for CPU-intensive tasks, creates threads matching CPU cores.
- **Dispatchers.IO:** Optimized for IO-bound tasks, like file operations or network requests.
- **Dispatchers.Main:** Executes operations on the UI thread, suitable for UI updates.
- **Dispatchers.Unconfined:** For coroutines without a specific thread context, can run on any thread.

**Coroutine Example:**
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val textView: TextView = findViewById(R.id.textView)
        CoroutineScope(Dispatchers.Main).launch {
            counter(textView)
        }
    }

    private suspend fun counter(view: TextView) {
        var count = 0
        while (true) {
            delay(1000)
            view.text = count.toString()
            count++
        }
    }
}
```

**Button Click with Coroutine Delay:**
```kotlin
button.setOnClickListener {
    Toast.makeText(this, "Hello, World!", Toast.LENGTH_LONG).show()
    runBlocking {
        delay(3000)
    }
}
```

---

### Tutorial 11: Mobile App Testing

**Unit Test Example:**
```kotlin
class Calculations(private val number1: Int, private val number2: Int) {
    fun addition() = number1 + number2
    fun subtraction() = number1 - number2
    fun multiplication() = number1 * number2
    fun division() = number1 / number2
}

class ExampleUnitTest {
    val calculations = Calculations(4, 5)

    @Test
    fun addition_isCorrect() {
        assertEquals(9, calculations.addition())
    }

    @Test
    fun subtraction_isCorrect() {
        assertEquals(-1, calculations.subtraction())
    }

    @Test
    fun multiplication_isCorrect() {
        assertEquals(20, calculations.multiplication())
    }

    @Test
    fun division_isCorrect() {
        assertEquals(0, calculations.division())
    }
}
```

---

### Button Click Handling

**Button Click Example:**
```kotlin
val myButton: Button = findViewById(R.id.myButton)
myButton.setOnClickListener {
    Toast.makeText(this, "Button clicked!", Toast.LENGTH_SHORT).show()
}
```

### Date Picker Handling

**Date Picker Example:**
```kotlin
val datePicker = findViewById<DatePicker>(R.id.datePicker)
datePicker.init(2024, 5, 28) { view, year, monthOfYear, dayOfMonth ->
    val selectedDate = "$dayOfMonth/${monthOfYear + 1}/$year"
    Toast.makeText(this, "Selected date: $selectedDate", Toast.LENGTH_SHORT).show()
}
```
**Best practices when writing unit tests**

Keep tests focused on a single functionality to pinpoint failures easily.
Use test doubles (mocks, stubs, fakes) to isolate code and identify specific component issues.
Utilize descriptive test names for clarity and quick issue identification.
Test edge cases (empty input, extreme values) to ensure comprehensive code coverage.

**Best Practices when using Instrumented Testing**
Keep test code separate from the app code for organization and clarity.
Ensure the use of the latest Android Studio version for updated features.
Employ AndroidX Test library for optimized testing APIs.
Select appropriate testing frameworks: JUnit for unit tests, Espresso for UI tests.

---
Type Inference - Automatically determines data types
 Null safety - Prevents null reference exceptions
---
Construct 2 entity data classes
data class User(
    val userId: Int,
    val name: String,
    val email: String,
    val password: String,
    val userType: String // "admin" or "customer"
)

data class Drink(
    val drinkId: Int,
    val name: String, 
    val description: String,
    val price: Double,
    val imageUrl: String?
)

---

Activity layouts:

*RegisterActivity

TextView (title)
EditText (name)
EditText (email)
EditText (password)
RadioGroup (userType)
RadioButton (admin)
RadioButton (customer)
Button (register)

*AdminHomeActivity

TextView (welcome message)
RecyclerView (drink list)
Button (add drink)
Button (view feedback)
---
*Navigation:
After registration, navigate to respective home activity (AdminHomeActivity or CustomerHomeActivity)
In home activities, click "Add Drink" to show add drink dialog
---

